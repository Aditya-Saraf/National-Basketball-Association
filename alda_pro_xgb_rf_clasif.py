# -*- coding: utf-8 -*-
"""alda-pro-xgb-RF-clasif

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/15S_ro2y1Ewk56H7MtbUlAtzGvHWYufx4
"""

from sklearn.cluster import KMeans
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.metrics import silhouette_score
from sklearn.model_selection import cross_val_score
from sklearn.model_selection import RepeatedKFold
from xgboost.sklearn import XGBRFClassifier

path = './data'

kmin = 2
kmax = 16

def silhouette(df):
  sil = []

  # dissimilarity would not be defined for a single cluster, thus, minimum number of clusters should be 2
  for k in range(kmin, kmax+1):
    kmeans = KMeans(n_clusters = k).fit(df)
    labels = kmeans.labels_
    sil.append(silhouette_score(df, labels, metric = 'euclidean'))
  return sil

pdf = pd.read_csv(path + '/player_all_data (1).csv').dropna()

new_pdf = pdf.copy()

pdf['bmi'] = pdf['weight'] / (pdf['height'] * pdf['height'])
pdf['pts_rg_gp'] = (pdf['pts_rg']+1) / (pdf['gp_rg']+1)
pdf['pts_po_gp'] = (pdf['pts_po']+1) / (pdf['gp_po']+1)
pdf['oreb_rg_gp'] = (pdf['oreb_rg']+1) / (pdf['gp_rg']+1)
pdf['oreb_po_gp'] = (pdf['oreb_po']+1) / (pdf['gp_po']+1)
pdf['dreb_rg_gp'] = (pdf['dreb_rg']+1) / (pdf['gp_rg']+1)
pdf['dreb_po_gp'] = (pdf['dreb_po']+1) / (pdf['gp_po']+1)
pdf['reb_rg_gp'] = (pdf['reb_rg']+1) / (pdf['gp_rg']+1)
pdf['reb_po_gp'] = (pdf['reb_po']+1) / (pdf['gp_po']+1)
pdf['asts_rg_gp'] = (pdf['asts_rg']+1) / (pdf['gp_rg']+1)
pdf['asts_po_gp'] = (pdf['asts_po']+1) / (pdf['gp_po']+1)
pdf['stl_rg_gp'] = (pdf['stl_rg']+1) / (pdf['gp_rg']+1)
pdf['stl_po_gp'] = (pdf['stl_po']+1) / (pdf['gp_po']+1)
pdf['blk_rg_gp'] = (pdf['blk_rg']+1) / (pdf['gp_rg']+1)
pdf['blk_po_gp'] = (pdf['blk_po']+1) / (pdf['gp_po']+1)
pdf['turnover_rg_gp'] = (pdf['turnover_rg']+1) / (pdf['gp_rg']+1)
pdf['turnover_po_gp'] = (pdf['turnover_po']+1) / (pdf['gp_po']+1)
pdf['pf_rg_gp'] = (pdf['pf_rg']+1) / (pdf['gp_rg']+1)
pdf['pf_po_gp'] = (pdf['pf_po']+1) / (pdf['gp_po']+1)
pdf['fga_rg_gp'] = (pdf['fga_rg']+1) / (pdf['gp_rg']+1)
pdf['fga_po_gp'] = (pdf['fga_po']+1) / (pdf['gp_po']+1)
pdf['fgm_rg_gp'] = (pdf['fgm_rg']+1) / (pdf['gp_rg']+1)
pdf['fgm_po_gp'] = (pdf['fgm_po']+1) / (pdf['gp_po']+1)
pdf['fta_rg_gp'] = (pdf['fta_rg']+1) / (pdf['gp_rg']+1)
pdf['fta_po_gp'] = (pdf['fta_po']+1) / (pdf['gp_po']+1)
pdf['ftm_rg_gp'] = (pdf['ftm_rg']+1) / (pdf['gp_rg']+1)
pdf['ftm_po_gp'] = (pdf['ftm_po']+1) / (pdf['gp_po']+1)
pdf['tpa_rg_gp'] = (pdf['tpa_rg']+1) / (pdf['gp_rg']+1)
pdf['tpa_po_gp'] = (pdf['tpa_po']+1) / (pdf['gp_po']+1)
pdf['tpm_rg_gp'] = (pdf['tpm_rg']+1) / (pdf['gp_rg']+1)
pdf['tpm_po_gp'] = (pdf['tpm_po']+1) / (pdf['gp_po']+1)
pdf['pts_po_gp'] = (pdf['pts_po']+1) / (pdf['gp_po']+1)


pdf['pts_gp'] = (pdf['pts']+1) / (pdf['gp']+1)
pdf['oreb_gp'] = (pdf['oreb']+1) / (pdf['gp']+1)

pdf['dreb_gp'] = (pdf['dreb']+1) / (pdf['gp']+1)

pdf['reb_gp'] = (pdf['reb']+1) / (pdf['gp']+1)

pdf['asts_gp'] = (pdf['asts']+1) / (pdf['gp']+1)

pdf['stl_gp'] = (pdf['stl']+1) / (pdf['gp']+1)

pdf['blk_gp'] = (pdf['blk']+1) / (pdf['gp']+1)

pdf['turnover_gp'] = (pdf['turnover']+1) / (pdf['gp']+1)

pdf['pf_gp'] = (pdf['pf']+1) / (pdf['gp']+1)

pdf['fga_gp'] = (pdf['fga']+1) / (pdf['gp']+1)

pdf['fgm_gp'] = (pdf['fgm']+1) / (pdf['gp']+1)

pdf['fta_gp'] = (pdf['fta']+1) / (pdf['gp']+1)

pdf['tpa_gp'] = (pdf['tpa']+1) / (pdf['gp']+1)

pdf['tpm_gp'] = (pdf['tpm']+1) / (pdf['gp']+1)

def meth(lab):
  pdf_lab = pdf[[lab]].copy()
  sil = silhouette(pdf_lab)
  s = np.array(sil)
  k = np.arange(kmin,kmax+1)
  plt.title("Silhouette Method")
  plt.xlabel("Number of Clusters (K)")
  plt.ylabel("Silhouette score")
  plt.plot(k, s, 'bx-', color ="blue")
  plt.show()
  smax = max(s)
  n_clusters = [item[0] for item in zip(k,s) if item[1] == smax][0]
  print(n_clusters)
  new_pdf[lab] = KMeans(n_clusters = n_clusters).fit(pdf_lab).labels_

meth('bmi')
meth('pts_rg_gp')
meth('pts_po_gp')
meth('oreb_rg_gp')
meth('oreb_po_gp')
meth('dreb_rg_gp')
meth('dreb_po_gp')
meth('reb_rg_gp')
meth('reb_po_gp')
meth('asts_rg_gp')
meth('asts_po_gp')
meth('stl_rg_gp')
meth('stl_po_gp')
meth('blk_rg_gp')
meth('blk_po_gp')
meth('turnover_rg_gp')
meth('turnover_po_gp')
meth('pf_rg_gp')
meth('pf_po_gp')
meth('fga_rg_gp')
meth('fga_po_gp')
meth('fgm_rg_gp')
meth('fgm_po_gp')
meth('fta_rg_gp')
meth('fta_po_gp')
meth('ftm_rg_gp')
meth('ftm_po_gp')
meth('tpa_rg_gp')
meth('tpa_po_gp')
meth('tpm_rg_gp')
meth('tpm_po_gp')
# non gp
meth('pts_rg')
meth('pts_po')
meth('oreb_rg')
meth('oreb_po')
meth('dreb_rg')
meth('dreb_po')
meth('reb_rg')
meth('reb_po')
meth('asts_rg')
meth('asts_po')
meth('stl_rg')
meth('stl_po')
meth('blk_rg')
meth('blk_po')
meth('turnover_rg')
meth('turnover_po')
meth('pf_rg')
meth('pf_po')
meth('fga_rg')
meth('fga_po')
meth('fgm_rg')
meth('fgm_po')
meth('fta_rg')
meth('fta_po')
meth('ftm_rg')
meth('ftm_po')
meth('tpa_rg')
meth('tpa_po')
meth('tpm_rg')
meth('tpm_po')

meth('pts_gp')

meth('oreb_gp')

meth('dreb_gp')

meth('reb_gp')

meth('asts_gp')

meth('stl_gp')

meth('blk_gp')

meth('turnover_gp')

meth('pf_gp')

meth('fga_gp')

meth('fgm_gp')

meth('fta_gp')

meth('tpa_gp')

meth('tpm_gp')

#

meth('pts')

meth('oreb')

meth('dreb')

meth('reb')

meth('asts')

meth('stl')

meth('blk')

meth('turnover')

meth('pf')

meth('fga')

meth('fgm')

meth('fta')

meth('tpa')

meth('tpm')

new_pdf['position_dis'] = new_pdf['position'].apply(lambda x: 0 if x=='G' else x).apply(lambda x: 1 if x=='C' else x).apply(lambda x: 2 if x=='F' else x)
pdf['position_dis'] = pdf['position'].apply(lambda x: 0 if x=='G' else x).apply(lambda x: 1 if x=='C' else x).apply(lambda x: 2 if x=='F' else x)
all_labs = ['position_dis', 'bmi','pts_rg_gp','pts_po_gp','oreb_rg_gp','oreb_po_gp','dreb_rg_gp','dreb_po_gp','reb_rg_gp','reb_po_gp','asts_rg_gp','asts_po_gp','stl_rg_gp','stl_po_gp','blk_rg_gp','blk_po_gp','turnover_rg_gp','turnover_po_gp','pf_rg_gp','pf_po_gp','fga_rg_gp','fga_po_gp','fgm_rg_gp','fgm_po_gp','fta_rg_gp','fta_po_gp','ftm_rg_gp','ftm_po_gp','tpa_rg_gp','tpa_po_gp','tpm_rg_gp','tpm_po_gp','pts_rg','pts_po','oreb_rg','oreb_po','dreb_rg','dreb_po','reb_rg','reb_po','asts_rg','asts_po','stl_rg','stl_po','blk_rg','blk_po','turnover_rg','turnover_po','pf_rg','pf_po','fga_rg','fga_po','fgm_rg','fgm_po','fta_rg','fta_po','ftm_rg','ftm_po','tpa_rg','tpa_po','tpm_rg','tpm_po','pts_gp','oreb_gp','dreb_gp','reb_gp','asts_gp','stl_gp','blk_gp','turnover_gp','pf_gp','fga_gp','fgm_gp','fta_gp','tpa_gp','tpm_gp','pts','oreb','dreb','reb','asts','stl','blk','turnover','pf','fga','fgm','fta','tpa','tpm']
dis_corr = new_pdf[all_labs].corr()
overall_corr = pdf[all_labs].corr()

labs_gp = ['position_dis','bmi','pts_rg_gp','pts_po_gp','oreb_rg_gp','oreb_po_gp','dreb_rg_gp','dreb_po_gp','reb_po_gp','reb_rg_gp','asts_rg_gp','asts_po_gp','stl_rg_gp','stl_po_gp','blk_rg_gp','blk_po_gp','turnover_rg_gp','turnover_po_gp','pf_rg_gp','pf_po_gp','fga_rg_gp','fga_po_gp','fgm_rg_gp','fgm_po_gp','fta_rg_gp','fta_po_gp','ftm_rg_gp','ftm_po_gp','tpa_rg_gp','tpa_po_gp','tpm_rg_gp','tpm_po_gp','pts_gp','oreb_gp','dreb_gp','reb_gp','asts_gp','stl_gp','blk_gp','turnover_gp','pf_gp','fga_gp','fgm_gp','fta_gp','tpa_gp','tpm_gp']
labs = ['position_dis','bmi','pts_rg','pts_po','oreb_rg','oreb_po','dreb_rg','dreb_po','reb_rg','reb_po','asts_rg','asts_po','stl_rg','stl_po','blk_rg','blk_po','turnover_rg','turnover_po','pf_rg','pf_po','fga_rg','fga_po','fgm_rg','fgm_po','fta_rg','fta_po','ftm_rg','ftm_po','tpa_rg','tpa_po','tpm_rg','tpm_po','pts','oreb','dreb','reb','asts','stl','blk','turnover','pf','fga','fgm','fta','tpa','tpm']
cv = RepeatedKFold(n_splits=3, n_repeats=3)
threshold = 0.5

"""

```
# This is formatted as code
```

Running classifier on discretized data per game"""

model = XGBRFClassifier()
# evaluate the model
graph_y_cdpg = []
for lab in labs_gp:
  X = new_pdf[labs_gp].drop(columns=[lab]).to_numpy()
  y = new_pdf[lab].to_numpy()
  n_scores = cross_val_score(model, X, y, scoring='accuracy', cv=cv, n_jobs=-1, error_score='raise')
  graph_y_cdpg.append(np.mean(n_scores))

"""Running classifier on discretized data"""

graph_y_cd = []
for lab in labs:
  X = new_pdf[labs].drop(columns=[lab]).to_numpy()
  y = new_pdf[lab].to_numpy()
  n_scores = cross_val_score(model, X, y, scoring='accuracy', cv=cv, n_jobs=-1, error_score='raise')
  graph_y_cd.append(np.mean(n_scores))

"""Running classifier on discretized data per game, but using only the attributes with correlation > threshold to train"""

graph_y_ncdpg = []
x_ncdpg = []
for lab in labs_gp:
  cols_to_drop = []
  for col in labs_gp:
    if abs(dis_corr[lab][col]) < threshold:
      cols_to_drop.append(col)
  X = new_pdf[labs_gp].drop(columns=cols_to_drop+[lab]).to_numpy()
  if len(X[0]) == 0:
    graph_y_ncdpg.append(0)
    continue
  y = new_pdf[lab].to_numpy()
  n_scores = cross_val_score(model, X, y, scoring='accuracy', cv=cv, n_jobs=-1, error_score='raise')
  graph_y_ncdpg.append(np.mean(n_scores))

ax = plt.figure(figsize=(30,5)).add_axes([0,0,1,1])
azip = [item for item in zip(labs, graph_y_cdpg) if item [1] > 0.9]
labs_fil, cdpg_fil = zip(*azip)
ax.bar(labs_fil, cdpg_fil)
plt.show()
ax = plt.figure(figsize=(30,5)).add_axes([0,0,1,1])
azip = [item for item in zip(labs, graph_y_cd) if item [1] > 0.9]
labs_fil, cd_fil = zip(*azip)
ax.bar(labs_fil, cd_fil, color= 'r')
plt.show()
ax = plt.figure(figsize=(30,5)).add_axes([0,0,1,1])
azip = [item for item in zip(labs, graph_y_ncdpg) if item [1] > 0.9]
labs_fil, ncdpg_fil = zip(*azip)
ax.bar(labs_fil, ncdpg_fil, color='g')
plt.show()
# plt.plot(labs, graph_y_ncd, 'c', label="ncd")

"""Running classifier using only discretized BMI and position on cumulative data"""

graph_y_bp = []
for lab in labs:
  if lab == 'bmi' or lab == 'position_dis':
    graph_y_bp.append(0)
    continue
  X = new_pdf[['bmi', 'position_dis']].to_numpy()
  y = new_pdf[lab].to_numpy()
  n_scores = cross_val_score(model, X, y, scoring='accuracy', cv=cv, n_jobs=-1, error_score='raise')
  graph_y_bp.append(np.mean(n_scores))

ax = plt.figure(figsize=(30,5)).add_axes([0,0,1,1])
azip = [item for item in zip(labs, graph_y_bp) if item [1] > 0.8]
labs_fil, bp_fil = zip(*azip)
ax.bar(labs_fil, bp_fil)
plt.show()

"""Running classifier using only discretized BMI and position on data per game"""

graph_y_bp3 = []
for lab in labs_gp:
  if lab == 'bmi' or lab == 'position_dis':
    graph_y_bp3.append(0)
    continue
  X = new_pdf[['bmi', 'position_dis']].to_numpy()
  y = new_pdf[lab].to_numpy()
  n_scores = cross_val_score(model, X, y, scoring='accuracy', cv=cv, n_jobs=-1, error_score='raise')
  graph_y_bp3.append(np.mean(n_scores))

ax = plt.figure(figsize=(30,5)).add_axes([0,0,1,1])
azip = [item for item in zip(labs, graph_y_bp3) if item [1] > 0.8]
labs_fil, bp_fil = zip(*azip)
ax.bar(labs_fil, bp_fil)
plt.show()